package com.next.model;/*    Mutton ... i get eaten*/import java.awt.*;import java.awt.geom.Point2D;public class Pray extends Thing {    /** Config**/    public static final double spawnProb = 0.1;    // probability of spawning pray    private double maxRadius = 3.0;                    // max circular size of all muttons    public Pray(double initX, double initY) {        super(initX, initY);        super.radius =  maxRadius;    // set a random radius for this mutton        super.drawColor = Color.YELLOW;        super.isStatic=true;    }    public void step() {        // check for collision with Gluttons        for (int i = 0; i < World.getInstance().getPredatorList().size(); i++) {            Predator curGlutton = World.getInstance().getPredatorList().get(i);//Predator.theGluttons[i];            // calculate distance between center of glutton and mutton            double xDistSqrd = Math.pow(curGlutton.xPos - this.xPos, 2);            double yDistSqrd = Math.pow(curGlutton.yPos- this.yPos, 2);            double cenDist = Math.sqrt(xDistSqrd + yDistSqrd);            // if distance less than sum of radii then a collision has occurred            if (cenDist < (curGlutton.radius + this.radius)) {                curGlutton.ateAMutton(this);            }        }        // moving in space        double xInc = (2 * Math.random() - 1) * super.stepSize;    // choose random x-direction step size and direction        double yInc = (2 * Math.random() - 1) * super.stepSize;    // choose random y-direction step size and direction        if (!isStatic) {            xPos += xInc;                                // increment x-position            yPos += yInc;                                // increment y-position        }        // crude boundary constraint        if (((xPos + radius) > maxX) | ((xPos - radius) < 0)) {            xPos += -2 * xInc;    // go other way if past boundary        }        if (((yPos + radius) > maxY) | ((yPos - radius) < 0)) {            yPos += -2 * yInc;    // go other way if past boundary        }    }    int xCenter;    int yCenter;    public void drawThing(Graphics g, double scale, double[] offset) {        g.setColor(this.drawColor);        int xCenter = (int) ((xPos - offset[0]) * scale);        int yCenter = (int) ((yPos - offset[1]) * scale);        int pixelRadius = (int) (radius * scale);        int pixelDiameter = (int) (2 * radius * scale);        this.xCenter = xCenter;        this.yCenter = yCenter;        g.drawOval(xCenter - pixelRadius, yCenter - pixelRadius, pixelDiameter, pixelDiameter);    }    public Point.Double getCenter(){        return new Point.Double((double)xCenter,(double)yCenter);    }}		