package com.next.model;/*    Glutton .... a Thing that eats and eats*/import com.next.ai.Brain;import java.awt.Point;import java.awt.Color;import java.util.ArrayList;import java.util.List;public class Predator extends Thing implements Comparable<Predator> {    private Brain brain;    /**     * Config     **/    private double shrinkProbability = 0.1;            // probability of shrinking if nothing eaten this step    private double minRadius = 1.0;                    // minimum size for the Predator    private double amountToShrink = 0.1;                // how much to shrink if shrinking event occurs    /**     * Step metadata     **/    private int eatenThisStep;                // a counter of Things eaten this time step    public Predator(double initX, double initY) {        super(initX, initY);        super.radius = minRadius;        super.drawColor = Color.RED;        brain = new Brain();        this.eatenThisStep = 0;    }    public void step() {        // shrinking if no food found        if (eatenThisStep == 0) {                        // if any food found            //if (Math.random() < shrinkProbability) {            // if no food than shrink stochastically            //    radius += -amountToShrink;            //}            //if (radius < minRadius) {            //    radius = minRadius;            //} // don't shrink beyond minimum        }        // moving in space        //double xInc = (2 * Math.random() - 1) * super.stepSize;    // choose random x-direction step size and direction        //double yInc = (2 * Math.random() - 1) * super.stepSize;    // choose random y-direction step size and direction        Pray closestPray = getClosestPray();        List<Double> inputs = new ArrayList<Double>();        inputs.add(closestPray.getXpos());        inputs.add(closestPray.getYpos());        List<Double> outputs = brain.getNetwork().compute(inputs);        //-0.5 allow negative movement in xy coords        double deltaX = (outputs.get(0)-0.5) * super.stepSize;        double deltaY = (outputs.get(1)-0.5) * super.stepSize;        //System.out.println("=================");        //System.out.println(deltaX);        //System.out.println(deltaY);        xPos += deltaX;                                // increment x-position        yPos += deltaY;                                // increment y-position        // crude boundary constraint        if (((xPos + radius) > maxX) | ((xPos - radius) < 0)) {            xPos += -2 * deltaX;    // go other way if past boundary        }        if (((yPos + radius) > maxY) | ((yPos - radius) < 0)) {            yPos += -2 * deltaY;    // go other way if past boundary        }        // reset counters        eatenThisStep = 0;    }    private Pray getClosestPray() {        Point myPos = new Point((int) this.xPos, (int) this.yPos);        double shortestDist = 10000000;        Pray closestPray = null;        for (Pray pray : World.getInstance().getPrayList()) {            Point prayPos = new Point((int) pray.getXpos(), (int) pray.getYpos());            if (prayPos.distance(myPos) < shortestDist) {                closestPray = pray;                shortestDist = prayPos.distance(myPos);            }        }        return closestPray;    }    public void ateAMutton(Pray eatenM) {        // add volume of mutton to this glutton and change radius accordingly        double muttonVol = Math.PI * eatenM.radius * eatenM.radius;        double newVol = muttonVol + Math.PI * radius * radius;        //radius = Math.sqrt(newVol / Math.PI);        eatenM.setIsDead(true);        // set flag so this Mutton will be removed        eatenThisStep++;        brain.incrementFitness(1);    }    @Override    public int compareTo(Predator o) {        //value less than 0 if the argument is a string lexicographically great        if (o.brain.getFitness() > this.brain.getFitness()) {            return -1;        }        if (o.brain.getFitness() < this.brain.getFitness()) {            return 1;        }        return 0;    }    public Brain getBrain() {        return brain;    }}