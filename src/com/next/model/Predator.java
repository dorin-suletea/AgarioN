package com.next.model;/*    Glutton .... a Thing that eats and eats*/import com.next.ai.Brain;import java.awt.*;import java.util.ArrayList;import java.util.List;public class Predator extends Thing implements Comparable<Predator> {    public double dMaxTurnRate = 0.7f;    private double drotaion = 0;    private Brain brain;    private Point.Double lookAt;    private double speed = 0.5;    /**     * Config     **/    private double shrinkProbability = 0.1;            // probability of shrinking if nothing eaten this step    private double minRadius = 1.0;                    // minimum size for the Predator    private double amountToShrink = 0.1;                // how much to shrink if shrinking event occurs    /**     * Step metadata     **/    private int eatenThisStep;                // a counter of Things eaten this time step    public Predator(double initX, double initY) {        super(initX, initY);        super.radius = minRadius;        super.drawColor = Color.RED;        brain = new Brain();        this.eatenThisStep = 0;        lookAt = new Point.Double(Math.random(), Math.random());    }    Pray closestPray = new Pray(0, 0);    public void step() {        // shrinking if no food found        if (eatenThisStep == 0) {                        // if any food found            //if (Math.random() < shrinkProbability) {            // if no food than shrink stochastically            //    radius += -amountToShrink;            //}            //if (radius < minRadius) {            //    radius = minRadius;            //} // don't shrink beyond minimum        }        // moving in space        //double xInc = (2 * Math.random() - 1) * super.stepSize;    // choose random x-direction step size and direction        //double yInc = (2 * Math.random() - 1) * super.stepSize;    // choose random y-direction step size and direction        closestPray = getClosestPray();        List<Double> inputs = new ArrayList<Double>();        inputs.add(closestPray.getCenter().x);        inputs.add(closestPray.getCenter().y);        inputs.add(lookAt.x);        inputs.add(lookAt.y);        List<Double> outputs = brain.computeDirection(inputs);        //System.out.println("[" + outputs.get(0) + ":" + outputs.get(1) + "]");        double rotationForce = outputs.get(0) - outputs.get(1);        rotationForce = Clamp(rotationForce, -dMaxTurnRate, dMaxTurnRate);        drotaion += rotationForce;        if (World.getInstance().getPredatorList().get(0) == this) {            System.out.println("Outputs : " + outputs);        }        //-0.5 allow negative movement in xy coords        //double deltaX = (outputs.get(0)) * super.stepSize;        //double deltaY = (outputs.get(1)) * super.stepSize;        //sign        //if (outputs.get(2)< outputs.get(3)){        //    deltaX = -deltaX;        // }        //if (outputs.get(4)< outputs.get(5)){        //    deltaY = -deltaY;        // }        //System.out.println("["+outputs.get(0)+ " "+ outputs.get(2)+"]"+"["+outputs.get(1)+ " "+ outputs.get(3)+"]");        double deltaX = lookAt.x * speed;        double deltaY = lookAt.y * speed;        xPos += deltaX;                                // increment x-position        yPos += deltaY;                                // increment y-position        // crude boundary constraint        if (((xPos + radius) > maxX) | ((xPos - radius) < 0)) {            xPos += -2 * deltaX;    // go other way if past boundary        }        if (((yPos + radius) > maxY) | ((yPos - radius) < 0)) {            yPos += -2 * deltaY;    // go other way if past boundary        }        // reset counters        eatenThisStep = 0;        lookAt.x = -Math.sin(drotaion);        lookAt.y = Math.cos(drotaion);    }    private Pray getClosestPray() {        Point myPos = new Point((int) this.xPos, (int) this.yPos);        double shortestDist = 10000000;        Pray closestPray = null;        for (Pray pray : World.getInstance().getPrayList()) {            Point prayPos = new Point((int) pray.getXpos(), (int) pray.getYpos());            if (prayPos.distance(myPos) < shortestDist) {                closestPray = pray;                shortestDist = prayPos.distance(myPos);            }        }        return closestPray;    }    public void ateAMutton(Pray eatenM) {        // add volume of mutton to this glutton and change radius accordingly        double muttonVol = Math.PI * eatenM.radius * eatenM.radius;        double newVol = muttonVol + Math.PI * radius * radius;        //radius = Math.sqrt(newVol / Math.PI);        eatenM.setIsDead(true);        // set flag so this Mutton will be removed        eatenThisStep++;        brain.incrementFitness(1);    }    @Override    public int compareTo(Predator o) {        //value less than 0 if the argument is a string lexicographically great        if (o.brain.getFitness() > this.brain.getFitness()) {            return -1;        }        if (o.brain.getFitness() < this.brain.getFitness()) {            return 1;        }        return 0;    }    @Override    public void drawThing(Graphics g, double scale, double[] offset) {        g.setColor(this.drawColor);        int xCenter = (int) ((xPos - offset[0]) * scale);        int yCenter = (int) ((yPos - offset[1]) * scale);        int pixelRadius = (int) (radius * scale);        int pixelDiameter = (int) (2 * radius * scale);        g.drawOval(xCenter - pixelRadius, yCenter - pixelRadius, pixelDiameter, pixelDiameter);        g.setColor(Color.green);        //g.drawLine(xCenter, yCenter, (int) closestPray.getCenter().x, (int) closestPray.getCenter().y);    }    public Brain getBrain() {        return brain;    }    private double Clamp(double arg, double min, double max) {        if (arg < min) {            arg = min;        }        if (arg > max) {            arg = max;        }        return arg;    }}